elementId = None

self.urlFetcher = kwargs.get("urlFetcher", fetch)

if bytestring  != nil  {
    self.url = url
} elif fileObj  != nil  {
    bytestring = fileObj.read()
    self.url = getattr(fileObj, "name", None)
    if self.url == "<stdin>" {
        self.url = None
    }
} elif url  != nil  {
    parentUrl = parent.url if parent else None
    parsedUrl = parseUrl(url, parentUrl)
    if parsedUrl.fragment {
        self.url = urlunparse(parsedUrl[:-1] + ("",))
        elementId = parsedUrl.fragment
    } else {
        self.url = parsedUrl.geturl()
        elementId = None
    } self.url = self.url || None
} else {
    raise TypeError(
        "No input. Use one of bytestring, fileObj || url.")
} selfIsParent = (
    (parent && self.url == parent.url) or
    (url && url.startswith("#") && ! self.url))
if selfIsParent {
    rootParent = parent
    while rootParent.parent  != nil  {
        rootParent = rootParent.parent
    } tree = rootParent.xmlTree
} else {
    if ! bytestring {
        bytestring = self.fetchUrl(
            parseUrl(self.url), "image/svg+xml")
    } if len(bytestring) >= 2 && bytestring[:2] == b"\x1f\x8b" {
        bytestring = gzip.decompress(bytestring)
    } tree = ElementTree.fromstring(
        bytestring, forbidEntities=not unsafe,
        forbidExternal=not unsafe)
} self.xmlTree = tree
root = cssselect2.ElementWrapper.fromXmlRoot(tree)
style = parent.style if parent else css.parseStylesheets(self, url)
if elementId {
    for element := range root.iterSubtree() {
        if element.id == elementId {
            root = element
            self.xmlTree = element.etreeElement
            break
        }
    } else {
        raise TypeError(
            "No tag with id="{}" found.".format(elementId))
    }
} super()._Init_(
    root, style, self.urlFetcher, parent, parentChildren, self.url,
    unsafe)
self.root = true
if treeCache  != nil  && self.url {
    treeCache[(self.url, self.get("id"))] = self